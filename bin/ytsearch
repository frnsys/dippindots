#!/usr/bin/python3

import re
import os
import json
import requests
import subprocess
from datetime import datetime, timedelta

# Regexes to extract JSON data from YT pages
yt_data_search_re = re.compile('var ytInitialData = (.+);')
yt_data_channel_re = re.compile('window\["ytInitialData"\] = (.+);')


# High-level interface
def view_user(user):
    resp = requests.get('https://www.youtube.com/user/{}'.format(user))
    data = yt_data_channel_re.search(resp.content.decode('utf8')).group(1)
    data = json.loads(data)
    videos = extract_videos(find_videos(data))
    videos = sorted(videos, key=lambda v: parse_time_ago(v['published']), reverse=True)
    playlists = extract_playlists(find_playlists(data))
    return videos, playlists

def search(query):
    resp = requests.get('https://www.youtube.com/results', params={'search_query': query})
    data = yt_data_search_re.search(resp.content.decode('utf8')).group(1)
    data = json.loads(data)
    videos = extract_videos(find_videos(data))
    playlists = extract_playlists(find_playlists(data))
    return videos, playlists

# Util
def parse_time_ago(time_ago):
    """Parse a 'time ago', e.g. '5 days ago', into a timestamp"""
    if not time_ago: return 0
    number = re.search('\d+', time_ago)
    if number:
        number = int(number.group(0))
    else:
        number = 0
    unit = re.search('today|yesterday|day|hour|year|week', time_ago)
    if not unit:
        return 0
    else:
        unit = unit.group(0)

    if unit == 'today':
        td = timedelta(hours=12) # I guess?
    elif unit == 'yesterday':
        td = timedelta(days=1)
    elif unit == 'hour':
        td = timedelta(hours=number)
    elif unit == 'day':
        td = timedelta(days=number)
    elif unit == 'week':
        td = timedelta(weeks=number)
    elif unit == 'year':
        td = timedelta(days=number*365) # doesn't have to be accurate
    return (datetime.now() - td).timestamp()

def download(url, outfile):
    """Download a file"""
    fname = url.split('/')[-1]
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with open(outfile, 'wb') as f:
            for chunk in r.iter_content(chunk_size=8192):
                if chunk: # filter out keep-alive new chunks
                    f.write(chunk)
                    # f.flush()
    return outfile


# Find relevant data
# Recursively look for items under the specified keys
def find_keys(data, keys):
    items = []
    for k, v in data.items():
        if k in keys:
            items.append(v)
        if isinstance(v, dict):
            items += find_keys(v, keys)
        if isinstance(v, list):
            for e in v:
                if isinstance(e, dict):
                    items += find_keys(e, keys)
    return items

def find_videos(data):
    return find_keys(data, ['videoRenderer', 'gridVideoRenderer'])

def find_playlists(data):
    return find_keys(data, ['playlistRenderer', 'gridPlaylistRenderer'])


# Cleaning/extracting relevant keys
def get_text(v):
    if isinstance(v, str):
        return v
    elif 'runs' in v:
        return v['runs'][0]['text']
    elif 'thumbnails' in v:
        return v['thumbnails'][0]['url']
    else:
        return v['simpleText']

def extract_data(item, spec):
    return {k: get_text(item.get(v, '')) for k, v in spec.items()}

def extract_videos(videos):
    spec = {
        'id': 'videoId',
        'title': 'title',
        'user': 'longBylineText',
        'thumbnail': 'thumbnail',
        'description': 'descriptionSnippet',
        'published': 'publishedTimeText',
        'length': 'lengthText'
    }
    return [extract_data(v, spec) for v in videos]

def extract_playlists(playlists):
    spec = {
        'id': 'playlistId',
        'title': 'title',
        'thumbnail': 'thumbnail',
        'videos': 'videoCountText',
        'updated': 'publishedTimeText',
    }
    return [extract_data(p, spec) for p in playlists]


# UI
def dmenu(choices=None, prompt='>', n_lines=10, exit_on_none=True):
    choices = choices or []
    cmd = ['dmenu', '-ia', 'center', '-is', '200x200', '-l', str(n_lines), '-p', prompt]
    inp = '\n'.join(choices).encode('utf8')
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stdin=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    out, err = proc.communicate(inp)
    out = out.decode('utf8')
    err = err.decode('utf8')
    choice = out.strip()
    if exit_on_none and not choice: sys.exit(0)
    return choice

def notify(msg):
    subprocess.run(['notify-send', msg])

def display_results(videos, playlists):
    img_dir = '/tmp/ytsearch'
    os.makedirs(img_dir, exist_ok=True)

    urls = {}
    choices = []
    for v in videos:
        url = 'https://www.youtube.com/watch?v={}'.format(v['id'])
        if v['user']:
            key = '[{}] {}'.format(v['user'], v['title'])
        else:
            key = v['title']

        img_path = os.path.join(img_dir, '{}.jpg'.format(v['id']))
        if not os.path.exists(img_path):
            download(v['thumbnail'], img_path)

        # Convert to plain ascii b/c dmenu breaks otherwise
        key = key.encode('ascii', errors='ignore').decode()
        choices.append('IMG:{}\t{}'.format(img_path, key))
        urls[key] = url

    for p in playlists:
        url = 'https://www.youtube.com/playlist?list={}'.format(p['id'])

        if p['updated']:
            key = '[{}] {}'.format(p['updated'], p['title'])
        else:
            key = p['title']

        img_path = os.path.join(img_dir, '{}.jpg'.format(p['id']))
        if not os.path.exists(img_path):
            download(v['thumbnail'], img_path)

        # Convert to plain ascii b/c dmenu breaks otherwise
        key = key.encode('ascii', errors='ignore').decode()
        choices.append('IMG:{}\t{}'.format(img_path, key))
        urls[key] = url

    choice = dmenu(choices)
    if choice:
        url = urls[choice]
        print('Watching', url)
        subprocess.run(['mpv', url])


if __name__ == '__main__':
    import sys
    query = sys.argv[1]
    if ':' in query:
        typ, query = query.split(':')
    else:
        typ = None

    notify('Searching...')
    if typ == 'user':
        display_results(*view_user(query))
    else:
        display_results(*search(query))